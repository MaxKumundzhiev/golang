package main

/*
Строки в Go используют кодировку UTF8.
Это значит, что фактически один символ может занимать от 1 до 4 байт.
Но мы помним, что строка — это массив байт.

Для работы с символами в Go есть тип руна (rune).
Они сами ведут учет, сколько байт занимает символ, и разработчику не нужно дополнительно это учитывать


В Go тип string и тип rune используются для работы с текстом, но выполняют разные роли.

Тип string представляет собой неизменяемую (immutable) последовательность байтов,
закодированных в UTF-8. Это означает, что строка хранит именно байты, а не символы,
и функция len(string) возвращает количество байтов, а не количество символов.
Например, символ "ш" занимает 2 байта, поэтому len("ш") вернёт 2, хотя визуально это один символ.
Строки удобно использовать для хранения и передачи текста, сетевых данных, работы с файлами,
HTTP-запросами и любыми операциями, где важна именно байтовая последовательность.

Тип rune — это представление одного Unicode-символа (code point) и является псевдонимом типа int32. О
н используется тогда, когда нужно работать именно с символами: например, при проверке палиндромов,
реверсе строк, изменении регистра (uppercase/lowercase), фильтрации букв и цифр,
корректной индексации символов Unicode и других операциях текстовой обработки.
Чтобы работать со строкой как с набором символов, её обычно преобразуют в []rune или итерируются через for range,
поскольку такой цикл автоматически декодирует UTF-8 и возвращает именно rune, а не байты.

Главное практическое правило:
- используйте string, когда храните или передаёте текст и работаете на уровне байтов;
- используйте rune, когда необходимо корректно обрабатывать отдельные символы Unicode;
- используйте []byte, когда работаете с бинарными данными, сетью, хешированием или файловыми потоками.

Важно помнить, что строка в Go фактически представляет собой read-only структуру вида «указатель на байты + длина»,
поэтому прямое индексирование строки (s[i]) возвращает байт, а не символ, и для Unicode-безопасной обработки нужно
использовать rune или range.
*/

import (
	"fmt"
	"unicode"
)

func isPalindrom(str string) bool {
	// palindrom means from from both sides reads same
	// lowercase input 
	runeStr := []rune(str)

	left, right := 0, len(runeStr)-1
	for left < right {
		if !unicode.IsLetter(runeStr[left]) && !unicode.IsDigit(runeStr[left]) {
			left ++
			continue
		}
		if !unicode.IsLetter(runeStr[right]) && !unicode.IsDigit(runeStr[right]) {
			right --
			continue
		}
		if unicode.ToLower(runeStr[left]) != unicode.ToLower(runeStr[right]) {
			return false
		}
		left ++
		right --
	}
	return true
}


func main() {
	// str := "Hello world"
	// fmt.Println(str)
	// fmt.Println(len(str))

	// runeStr := []rune(str)
	// fmt.Println(runeStr)
	// fmt.Println(len(runeStr))
	fmt.Println(isPalindrom("abA"))
}
